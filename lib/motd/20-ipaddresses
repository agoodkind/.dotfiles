#!/usr/bin/env bash
# Display IP addresses for each network interface

# Requires bash 4+ for associative arrays and `mapfile` (macOS /bin/bash is 3.2).
if [[ -z "${BASH_VERSINFO[0]:-}" || "${BASH_VERSINFO[0]}" -lt 4 ]]; then
    exit 0
fi

declare -A ipv4_arrays
declare -A ipv6_arrays

# Strip ANSI color codes for alignment calculations
strip_ansi() {
    sed -E 's/\x1B\[[0-9;]*m//g'
}

visible_len() {
    local s=$1
    local stripped
    stripped=$(printf '%s' "$s" | strip_ansi)
    printf '%s' "${#stripped}"
}

get_public_ip() {
    local ver=$1
    command -v curl >/dev/null 2>&1 || { printf '%s\n' "N/A"; return; }
    curl -"${ver}" -s --connect-timeout 2 --max-time 3 \
        ifconfig.co 2>/dev/null || printf '%s\n' "N/A"
}

get_isp() {
    command -v curl >/dev/null 2>&1 || { printf '%s\n' "N/A"; return; }
    local org
    org=$(curl -s --connect-timeout 2 --max-time 3 \
        https://ipinfo.io/org 2>/dev/null)
    if [[ -n "$org" ]]; then
        printf '%s\n' "$org"
    else
        printf '%s\n' "N/A"
    fi
}

# Optional color configuration (disabled if NO_COLOR is set or output is not a TTY)
bold=""
dim=""
reset=""
iface_colors=()
subnet_colors=()
host_color=""        # global color for host bits (lower bits), same everywhere
declare -A subnet_color_cache
declare -A subnet_index_cache

if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
    bold=$'\e[1m'
    dim=$'\e[2m'
    reset=$'\e[0m'

    # Interface colors: bold & bright so they stand out clearly on dark backgrounds
    iface_colors=(
        $'\e[1;91m' # bright red
        $'\e[1;92m' # bright green
        $'\e[1;93m' # bright yellow
        $'\e[1;94m' # bright blue
        $'\e[1;95m' # bright magenta
        $'\e[1;96m' # bright cyan
    )

    # Subnet colors: bright, non‑bold variants; avoid dark/gray tones for readability.
    subnet_colors=(
        $'\e[91m' # bright red
        $'\e[92m' # bright green
        $'\e[93m' # bright yellow
        $'\e[94m' # bright blue
        $'\e[95m' # bright magenta
        $'\e[96m' # bright cyan
    )

    # Host bits (lower bits) color: single universal style, distinct from the palettes above
    host_color=$'\e[1;97m' # bright white, bold
fi

# Return a "subnet key" for an IP:
# - IPv4: /24, e.g. 10.250.1.53 -> 10.250.1.0/24
# - IPv6: /64 approximated by first 4 hextets, e.g. 3d06:bad:b01:4::64 -> 3d06:bad:b01:4
subnet_key_for_ip() {
    local ip=$1

    # IPv4
    if [[ "$ip" == *.* ]]; then
        local o1 o2 o3
        IFS='.' read -r o1 o2 o3 _ <<< "$ip"
        [[ -z "$o1" || -z "$o2" || -z "$o3" ]] && return
        printf '%s\n' "${o1}.${o2}.${o3}.0/24"
        return
    fi

    # IPv6
    local parts=()
    local part
    IFS=':' read -ra parts <<< "$ip"
    local count=0
    local key_parts=()

    for part in "${parts[@]}"; do
        [[ -z "$part" ]] && continue
        key_parts+=("$part")
        ((count++))
        [[ $count -ge 4 ]] && break
    done

    if [[ ${#key_parts[@]} -gt 0 ]]; then
        printf '%s\n' "$(IFS=':'; echo "${key_parts[*]}")"
    fi
}

# Deterministically map a subnet key to a color index so colors are stable
subnet_color_for_key() {
    local key=$1

    [[ -z "$key" ]] && return
    [[ ${#subnet_colors[@]} -eq 0 ]] && return

    # Cached?
    if [[ -n "${subnet_color_cache[$key]:-}" ]]; then
        printf '%s\n' "${subnet_color_cache[$key]}"
        return
    fi

    # Simple string hash (djb2 style) in pure bash
    local hash=0
    local i char_code
    for ((i=0; i<${#key}; i++)); do
        printf -v char_code '%d' "'${key:i:1}"
        hash=$(((hash * 33 + char_code) & 0x7fffffff))
    done

    local idx=$((hash % ${#subnet_colors[@]}))
    subnet_index_cache[$key]=$idx
    subnet_color_cache[$key]="${subnet_colors[$idx]}"
    printf '%s\n' "${subnet_colors[$idx]}"
}

# For a given subnet key, return a contrasting color (used for host bits),
# chosen deterministically so results are stable across runs.
subnet_contrast_color_for_key() {
    local key=$1

    [[ -z "$key" ]] && return
    [[ ${#subnet_colors[@]} -eq 0 ]] && return

    local idx
    if [[ -n "${subnet_index_cache[$key]:-}" ]]; then
        idx=${subnet_index_cache[$key]}
    else
        # Ensure color/index are initialized
        subnet_color_for_key "$key" >/dev/null
        idx=${subnet_index_cache[$key]}
    fi

    # Pick a color roughly opposite in the palette for contrast
    local palette_len=${#subnet_colors[@]}
    local offset=$((palette_len / 2))
    local contrast_idx=$(((idx + offset) % palette_len))
    printf '%s\n' "${subnet_colors[$contrast_idx]}"
}

# Add IP address to array for interface
add_ip() {
    local iface=$1
    local ip=$2
    local type=$3
    
    if [[ "$type" == "ipv4" ]]; then
        [[ -z "${ipv4_arrays[$iface]}" ]] && ipv4_arrays[$iface]=""
        [[ -n "${ipv4_arrays[$iface]}" ]] && ipv4_arrays[$iface]+=" "
        ipv4_arrays[$iface]+="$ip"
    else
        [[ -z "${ipv6_arrays[$iface]}" ]] && ipv6_arrays[$iface]=""
        [[ -n "${ipv6_arrays[$iface]}" ]] && ipv6_arrays[$iface]+=" "
        ipv6_arrays[$iface]+="$ip"
    fi
}

# Parse network interface output
# Use cached OS_TYPE if available, fallback to uname
[[ -z "$OS_TYPE" ]] && [[ -f ~/.cache/os-type.cache ]] && OS_TYPE=$(cat ~/.cache/os-type.cache)
[[ -z "$OS_TYPE" ]] && [[ "$(uname)" == "Darwin" ]] && OS_TYPE="mac"

if [[ "$OS_TYPE" == "mac" ]]; then
    command -v ifconfig >/dev/null 2>&1 || exit 0
    
    current_iface=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^([^:]+):[[:space:]]+flags= ]]; then
            current_iface="${BASH_REMATCH[1]}"
            continue
        fi
        
        [[ -z "$current_iface" ]] && continue
        
        if [[ "$line" =~ [[:space:]]+inet[[:space:]]+([0-9.]+) ]]; then
            ip="${BASH_REMATCH[1]}"
            [[ "$ip" =~ ^127\. ]] && continue
            add_ip "$current_iface" "$ip" "ipv4"
        elif [[ "$line" =~ [[:space:]]+inet6[[:space:]]+([0-9a-fA-F:]+) ]]; then
            ip6="${BASH_REMATCH[1]%%%*}"
            [[ "$ip6" == "::1" ]] && continue
            [[ "$ip6" =~ ^fe80:: ]] && continue
            add_ip "$current_iface" "$ip6" "ipv6"
        fi
    done < <(ifconfig -a 2>/dev/null)
else
    command -v ip >/dev/null 2>&1 || exit 0
    
    current_iface=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+:[[:space:]]+([^:]+): ]]; then
            current_iface="${BASH_REMATCH[1]}"
            continue
        fi
        
        [[ -z "$current_iface" ]] && continue
        
        if [[ "$line" =~ [[:space:]]+inet[[:space:]]+([0-9.]+) ]]; then
            ip="${BASH_REMATCH[1]}"
            [[ "$ip" =~ ^127\. ]] && continue
            add_ip "$current_iface" "$ip" "ipv4"
        elif [[ "$line" =~ [[:space:]]+inet6[[:space:]]+([0-9a-fA-F:]+) ]]; then
            ip6="${BASH_REMATCH[1]}"
            [[ "$ip6" == "::1" ]] && continue
            [[ "$ip6" =~ ^fe80:: ]] && continue
            add_ip "$current_iface" "$ip6" "ipv6"
        fi
    done < <(ip addr show 2>/dev/null)
fi

mapfile -t all_interfaces < <(printf '%s\n' "${!ipv4_arrays[@]}" "${!ipv6_arrays[@]}" | sort -u)
[[ ${#all_interfaces[@]} -eq 0 ]] && exit 0

left_lines=()

left_lines+=("")
left_lines+=("IP Addresses:")

top_prefix="  "
num_ifaces=${#all_interfaces[@]}

for idx in "${!all_interfaces[@]}"; do
    iface="${all_interfaces[$idx]}"

    v6_addrs=()
    v4_addrs=()

    [[ -n "${ipv6_arrays[$iface]}" ]] && read -ra v6_addrs <<< "${ipv6_arrays[$iface]}"
    [[ -n "${ipv4_arrays[$iface]}" ]] && read -ra v4_addrs <<< "${ipv4_arrays[$iface]}"

    all_addrs=("${v6_addrs[@]}" "${v4_addrs[@]}")
    [[ ${#all_addrs[@]} -eq 0 ]] && continue

    # Build subnet information for this interface so we can pick a dominant subnet
    declare -A subnet_counts=()
    addr_subnet_keys=()
    for i in "${!all_addrs[@]}"; do
        skey=$(subnet_key_for_ip "${all_addrs[$i]}")
        addr_subnet_keys[$i]="$skey"
        [[ -z "$skey" ]] && continue
        ((subnet_counts["$skey"]++))
    done

    dominant_key=""
    dominant_count=0
    for key in "${!subnet_counts[@]}"; do
        count=${subnet_counts[$key]}
        if (( count > dominant_count )) || \
            { (( count == dominant_count )) && \
            [[ -n "$key" && ( -z "$dominant_key" || "$key" < "$dominant_key" ) ]]; }
        then
            dominant_key="$key"
            dominant_count=$count
        fi
    done
    dominant_color=""
    if [[ -n "$dominant_key" ]]; then
        dominant_color=$(subnet_color_for_key "$dominant_key")
    fi

    # Determine if this is the last interface for tree drawing
    if [[ $idx -eq $((num_ifaces - 1)) ]]; then
        iface_connector="└─"
        addr_prefix="${top_prefix}   "
    else
        iface_connector="├─"
        addr_prefix="${top_prefix}│  "
    fi

    # Build colored interface label
    iface_label="$iface"
    if [[ -n "$dominant_color" || ${#iface_colors[@]} -gt 0 ]]; then
        base_color="$dominant_color"
        if [[ -z "$base_color" && ${#iface_colors[@]} -gt 0 ]]; then
            color_idx=$((idx % ${#iface_colors[@]}))
            base_color="${iface_colors[$color_idx]}"
        fi

        if [[ "$iface" == *"@"* ]]; then
            vlan_part="${iface%%@*}"
            parent_part="${iface#*@}"

            iface_label="${bold}${base_color}${vlan_part}${reset}@"
            if [[ -n "$dim" ]]; then
                iface_label+="${dim}${base_color}${parent_part}${reset}"
            else
                iface_label+="${base_color}${parent_part}${reset}"
            fi
        else
            iface_label="${bold}${base_color}${iface}${reset}"
        fi
    fi

    left_lines+=("$(printf "%s%s %s" "$top_prefix" "$iface_connector" \
        "$iface_label")")

    # Addresses for this interface
    num_addrs=${#all_addrs[@]}
    for i in "${!all_addrs[@]}"; do
        if [[ $i -eq $((num_addrs - 1)) ]]; then
            addr_connector="└─"
        else
            addr_connector="├─"
        fi

        addr_label="${all_addrs[$i]}"
        subnet_key="${addr_subnet_keys[$i]}"
        subnet_color=$(subnet_color_for_key "$subnet_key")
        if [[ -n "$subnet_color" ]]; then
            if [[ "${all_addrs[$i]}" == *.* ]]; then
                o1="" o2="" o3="" o4=""
                IFS='.' read -r o1 o2 o3 o4 <<< "${all_addrs[$i]}"
                if [[ -n "$o1" && -n "$o2" && -n "$o3" && -n "$o4" ]]; then
                    net_part="${o1}.${o2}.${o3}."
                    host_part="$o4"
                    if [[ -n "$host_color" ]]; then
                        addr_label="${bold}${subnet_color}${net_part}${reset}"
                        addr_label+="${host_color}${host_part}${reset}"
                    else
                        addr_label="${bold}${subnet_color}${all_addrs[$i]}${reset}"
                    fi
                else
                    addr_label="${bold}${subnet_color}${all_addrs[$i]}${reset}"
                fi
            else
                ip6="${all_addrs[$i]}"
                if [[ -n "$host_color" && -n "$subnet_key" && "$ip6" == "$subnet_key"* ]]
                then
                    net_part="$subnet_key"
                    host_part="${ip6#"$subnet_key"}"
                    if [[ -n "$host_part" ]]; then
                        addr_label="${subnet_color}${net_part}${reset}"
                        addr_label+="${host_color}${host_part}${reset}"
                    else
                        addr_label="${subnet_color}${ip6}${reset}"
                    fi
                else
                    addr_label="${subnet_color}${ip6}${reset}"
                fi
            fi
        elif [[ -n "$dim" ]]; then
            addr_label="${dim}${addr_label}${reset}"
        fi

        left_lines+=("$(printf "%s%s %s" "$addr_prefix" "$addr_connector" \
            "$addr_label")")
    done
done

pub4=$(get_public_ip 4)
pub6=$(get_public_ip 6)
isp=$(get_isp)

right_lines=()
right_lines+=("")
right_lines+=("Internet:")
right_lines+=("  ├─ Public IPv4: ${pub4}")
right_lines+=("  ├─ Public IPv6: ${pub6}")
right_lines+=("  └─ ISP: ${isp}")

max_left=0
for line in "${left_lines[@]}"; do
    l=$(visible_len "$line")
    (( l > max_left )) && max_left=$l
done

pad_width=$((max_left + 4))

num_lines=${#left_lines[@]}
for ((i = 0; i < num_lines; i++)); do
    left="${left_lines[$i]}"
    right="${right_lines[$i]:-}"
    if [[ -z "$right" ]]; then
        printf '%b\n' "$left"
        continue
    fi

    left_len=$(visible_len "$left")
    spaces=$((pad_width - left_len))
    (( spaces < 1 )) && spaces=1

    printf '%b' "$left"
    printf '%*s' "$spaces" ""
    printf '%s\n' "$right"
done

printf "\n"