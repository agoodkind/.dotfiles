#!/usr/bin/env bash
# Display IP addresses for each network interface

declare -A ipv4_arrays
declare -A ipv6_arrays

# Optional color configuration (disabled if NO_COLOR is set or output is not a TTY)
bold=""
dim=""
reset=""
iface_colors=()
subnet_colors=()
host_color=""        # global color for host bits (lower bits), same everywhere
declare -A subnet_color_cache
declare -A subnet_index_cache

if [[ -t 1 && -z "${NO_COLOR:-}" ]]; then
    bold=$'\e[1m'
    dim=$'\e[2m'
    reset=$'\e[0m'

    # Interface colors: bold & bright so they stand out clearly on dark backgrounds
    iface_colors=(
        $'\e[1;91m' # bright red
        $'\e[1;92m' # bright green
        $'\e[1;93m' # bright yellow
        $'\e[1;94m' # bright blue
        $'\e[1;95m' # bright magenta
        $'\e[1;96m' # bright cyan
    )

    # Subnet colors: bright, non‑bold variants; avoid dark/gray tones for readability.
    subnet_colors=(
        $'\e[91m' # bright red
        $'\e[92m' # bright green
        $'\e[93m' # bright yellow
        $'\e[94m' # bright blue
        $'\e[95m' # bright magenta
        $'\e[96m' # bright cyan
    )

    # Host bits (lower bits) color: single universal style, distinct from the palettes above
    host_color=$'\e[1;97m' # bright white, bold
fi

# Return a "subnet key" for an IP:
# - IPv4: /24, e.g. 10.250.1.53 -> 10.250.1.0/24
# - IPv6: /64 approximated by first 4 hextets, e.g. 3d06:bad:b01:4::64 -> 3d06:bad:b01:4
subnet_key_for_ip() {
    local ip=$1

    # IPv4
    if [[ "$ip" == *.* ]]; then
        local o1 o2 o3
        IFS='.' read -r o1 o2 o3 _ <<< "$ip"
        [[ -z "$o1" || -z "$o2" || -z "$o3" ]] && return
        printf '%s\n' "${o1}.${o2}.${o3}.0/24"
        return
    fi

    # IPv6
    local parts=()
    local part
    IFS=':' read -ra parts <<< "$ip"
    local count=0
    local key_parts=()

    for part in "${parts[@]}"; do
        [[ -z "$part" ]] && continue
        key_parts+=("$part")
        ((count++))
        [[ $count -ge 4 ]] && break
    done

    if [[ ${#key_parts[@]} -gt 0 ]]; then
        printf '%s\n' "$(IFS=':'; echo "${key_parts[*]}")"
    fi
}

# Deterministically map a subnet key to a color index so colors are stable
subnet_color_for_key() {
    local key=$1

    [[ -z "$key" ]] && return
    [[ ${#subnet_colors[@]} -eq 0 ]] && return

    # Cached?
    if [[ -n "${subnet_color_cache[$key]:-}" ]]; then
        printf '%s\n' "${subnet_color_cache[$key]}"
        return
    fi

    # Simple string hash (djb2 style) in pure bash
    local hash=0
    local i char_code
    for ((i=0; i<${#key}; i++)); do
        printf -v char_code '%d' "'${key:i:1}"
        hash=$(((hash * 33 + char_code) & 0x7fffffff))
    done

    local idx=$((hash % ${#subnet_colors[@]}))
    subnet_index_cache[$key]=$idx
    subnet_color_cache[$key]="${subnet_colors[$idx]}"
    printf '%s\n' "${subnet_colors[$idx]}"
}

# For a given subnet key, return a contrasting color (used for host bits),
# chosen deterministically so results are stable across runs.
subnet_contrast_color_for_key() {
    local key=$1

    [[ -z "$key" ]] && return
    [[ ${#subnet_colors[@]} -eq 0 ]] && return

    local idx
    if [[ -n "${subnet_index_cache[$key]:-}" ]]; then
        idx=${subnet_index_cache[$key]}
    else
        # Ensure color/index are initialized
        subnet_color_for_key "$key" >/dev/null
        idx=${subnet_index_cache[$key]}
    fi

    # Pick a color roughly opposite in the palette for contrast
    local palette_len=${#subnet_colors[@]}
    local offset=$((palette_len / 2))
    local contrast_idx=$(((idx + offset) % palette_len))
    printf '%s\n' "${subnet_colors[$contrast_idx]}"
}

# Add IP address to array for interface
add_ip() {
    local iface=$1
    local ip=$2
    local type=$3
    
    if [[ "$type" == "ipv4" ]]; then
        [[ -z "${ipv4_arrays[$iface]}" ]] && ipv4_arrays[$iface]=""
        [[ -n "${ipv4_arrays[$iface]}" ]] && ipv4_arrays[$iface]+=" "
        ipv4_arrays[$iface]+="$ip"
    else
        [[ -z "${ipv6_arrays[$iface]}" ]] && ipv6_arrays[$iface]=""
        [[ -n "${ipv6_arrays[$iface]}" ]] && ipv6_arrays[$iface]+=" "
        ipv6_arrays[$iface]+="$ip"
    fi
}

# Parse network interface output
# Use cached OS_TYPE if available, fallback to uname
[[ -z "$OS_TYPE" ]] && [[ -f ~/.cache/os-type.cache ]] && OS_TYPE=$(cat ~/.cache/os-type.cache)
[[ -z "$OS_TYPE" ]] && [[ "$(uname)" == "Darwin" ]] && OS_TYPE="mac"

if [[ "$OS_TYPE" == "mac" ]]; then
    command -v ifconfig >/dev/null 2>&1 || exit 0
    
    current_iface=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^([^:]+):[[:space:]]+flags= ]]; then
            current_iface="${BASH_REMATCH[1]}"
            continue
        fi
        
        [[ -z "$current_iface" ]] && continue
        
        if [[ "$line" =~ [[:space:]]+inet[[:space:]]+([0-9.]+) ]]; then
            ip="${BASH_REMATCH[1]}"
            [[ "$ip" =~ ^127\. ]] && continue
            add_ip "$current_iface" "$ip" "ipv4"
        elif [[ "$line" =~ [[:space:]]+inet6[[:space:]]+([0-9a-fA-F:]+) ]]; then
            ip6="${BASH_REMATCH[1]%%%*}"
            [[ "$ip6" == "::1" ]] && continue
            [[ "$ip6" =~ ^fe80:: ]] && continue
            add_ip "$current_iface" "$ip6" "ipv6"
        fi
    done < <(ifconfig -a 2>/dev/null)
else
    command -v ip >/dev/null 2>&1 || exit 0
    
    current_iface=""
    while IFS= read -r line; do
        if [[ "$line" =~ ^[0-9]+:[[:space:]]+([^:]+): ]]; then
            current_iface="${BASH_REMATCH[1]}"
            continue
        fi
        
        [[ -z "$current_iface" ]] && continue
        
        if [[ "$line" =~ [[:space:]]+inet[[:space:]]+([0-9.]+) ]]; then
            ip="${BASH_REMATCH[1]}"
            [[ "$ip" =~ ^127\. ]] && continue
            add_ip "$current_iface" "$ip" "ipv4"
        elif [[ "$line" =~ [[:space:]]+inet6[[:space:]]+([0-9a-fA-F:]+) ]]; then
            ip6="${BASH_REMATCH[1]}"
            [[ "$ip6" == "::1" ]] && continue
            [[ "$ip6" =~ ^fe80:: ]] && continue
            add_ip "$current_iface" "$ip6" "ipv6"
        fi
    done < <(ip addr show 2>/dev/null)
fi

mapfile -t all_interfaces < <(printf '%s\n' "${!ipv4_arrays[@]}" "${!ipv6_arrays[@]}" | sort -u)
[[ ${#all_interfaces[@]} -eq 0 ]] && exit 0

echo ""
echo "IP Addresses:"

top_prefix="  "
num_ifaces=${#all_interfaces[@]}

for idx in "${!all_interfaces[@]}"; do
    iface="${all_interfaces[$idx]}"

    v6_addrs=()
    v4_addrs=()
    
    [[ -n "${ipv6_arrays[$iface]}" ]] && read -ra v6_addrs <<< "${ipv6_arrays[$iface]}"
    [[ -n "${ipv4_arrays[$iface]}" ]] && read -ra v4_addrs <<< "${ipv4_arrays[$iface]}"
    
    all_addrs=("${v6_addrs[@]}" "${v4_addrs[@]}")
    [[ ${#all_addrs[@]} -eq 0 ]] && continue

    # Build subnet information for this interface so we can pick a dominant subnet
    declare -A subnet_counts=()
    addr_subnet_keys=()
    for i in "${!all_addrs[@]}"; do
        skey=$(subnet_key_for_ip "${all_addrs[$i]}")
        addr_subnet_keys[$i]="$skey"
        [[ -z "$skey" ]] && continue
        ((subnet_counts["$skey"]++))
    done

    dominant_key=""
    dominant_count=0
    for key in "${!subnet_counts[@]}"; do
        count=${subnet_counts[$key]}
        if (( count > dominant_count )) || { (( count == dominant_count )) && [[ -n "$key" && ( -z "$dominant_key" || "$key" < "$dominant_key" ) ]]; }; then
            dominant_key="$key"
            dominant_count=$count
        fi
    done
    dominant_color=""
    if [[ -n "$dominant_key" ]]; then
        dominant_color=$(subnet_color_for_key "$dominant_key")
    fi

    # Determine if this is the last interface for tree drawing
    if [[ $idx -eq $((num_ifaces - 1)) ]]; then
        iface_connector="└─"
        addr_prefix="${top_prefix}   "
    else
        iface_connector="├─"
        addr_prefix="${top_prefix}│  "
    fi

    # Build colored interface label:
    # - prefer the color of the dominant subnet for this interface
    # - fall back to per-interface palette if subnet colors aren't available
    # - if the interface is a VLAN (e.g. vlan0100@enp1s0), make the VLAN
    #   name the primary (bold) part and the parent interface a secondary,
    #   softer-colored part.
    iface_label="$iface"
    if [[ -n "$dominant_color" || ${#iface_colors[@]} -gt 0 ]]; then
        # Decide base color for this interface
        base_color="$dominant_color"
        if [[ -z "$base_color" && ${#iface_colors[@]} -gt 0 ]]; then
            color_idx=$((idx % ${#iface_colors[@]}))
            base_color="${iface_colors[$color_idx]}"
        fi

        if [[ "$iface" == *"@"* ]]; then
            vlan_part="${iface%%@*}"
            parent_part="${iface#*@}"

            # Primary: VLAN name, bold in base_color
            iface_label="${bold}${base_color}${vlan_part}${reset}@"

            # Secondary: parent interface, dimmer in same color so it is readable
            if [[ -n "$dim" ]]; then
                iface_label+="${dim}${base_color}${parent_part}${reset}"
            else
                iface_label+="${base_color}${parent_part}${reset}"
            fi
        else
            # Non‑VLAN: just bold the whole interface name
            iface_label="${bold}${base_color}${iface}${reset}"
        fi
    fi

    # Print interface line
    printf "%s%s %s\n" "$top_prefix" "$iface_connector" "$iface_label"

    # Print all addresses for this interface
    num_addrs=${#all_addrs[@]}
    for i in "${!all_addrs[@]}"; do
        if [[ $i -eq $((num_addrs - 1)) ]]; then
            addr_connector="└─"
        else
            addr_connector="├─"
        fi

        addr_label="${all_addrs[$i]}"
        # Color by subnet so that similar networks share a stable color.
        # Make IPv4 more visually prominent than IPv6 and highlight the host bits
        # (lower bits) with a universal host color while keeping colors stable.
        subnet_key="${addr_subnet_keys[$i]}"
        subnet_color=$(subnet_color_for_key "$subnet_key")
        if [[ -n "$subnet_color" ]]; then
            if [[ "${all_addrs[$i]}" == *.* ]]; then
                # IPv4: emphasize, and color network vs host differently
                o1="" o2="" o3="" o4=""
                IFS='.' read -r o1 o2 o3 o4 <<< "${all_addrs[$i]}"
                if [[ -n "$o1" && -n "$o2" && -n "$o3" && -n "$o4" ]]; then
                    net_part="${o1}.${o2}.${o3}."
                    host_part="$o4"
                    if [[ -n "$host_color" ]]; then
                        # Network portion: bold in subnet color
                        # Host portion: bold in the global host color
                        addr_label="${bold}${subnet_color}${net_part}${reset}${host_color}${host_part}${reset}"
                    else
                        # Fallback: bold whole IPv4 in subnet color
                        addr_label="${bold}${subnet_color}${all_addrs[$i]}${reset}"
                    fi
                else
                    addr_label="${bold}${subnet_color}${all_addrs[$i]}${reset}"
                fi
            else
                # IPv6: subnet color for upper bits, global host color for host bits (if detectable),
                # and non‑bold overall so v6 is visually softer than v4.
                ip6="${all_addrs[$i]}"
                if [[ -n "$host_color" && -n "$subnet_key" && "$ip6" == "$subnet_key"* ]]; then
                    net_part="$subnet_key"
                    host_part="${ip6#"$subnet_key"}"
                    if [[ -n "$host_part" ]]; then
                        addr_label="${subnet_color}${net_part}${reset}${host_color}${host_part}${reset}"
                    else
                        addr_label="${subnet_color}${ip6}${reset}"
                    fi
                else
                    addr_label="${subnet_color}${ip6}${reset}"
                fi
            fi
        elif [[ -n "$dim" ]]; then
            # Fallback to dimming if colors are disabled but dim style is available
            addr_label="${dim}${addr_label}${reset}"
        fi

        printf "%s%s %s\n" "$addr_prefix" "$addr_connector" "$addr_label"
    done
done

printf "\n"