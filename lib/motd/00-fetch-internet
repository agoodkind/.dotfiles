#!/usr/bin/env bash
#
# Async fetch of internet info for later MOTD scripts.
# Writes cached values to ~/.cache/motd/internet.env
#

set -euo pipefail

cache_dir="${HOME}/.cache/motd"
cache_file="${cache_dir}/internet.env"
lock_dir="${cache_dir}/internet.lock"

command -v curl >/dev/null 2>&1 || exit 0

mkdir -p "$cache_dir"

if ! mkdir "$lock_dir" 2>/dev/null; then
    exit 0
fi

(
    set -euo pipefail

    # Race multiple URLs in parallel; first to complete with data wins
    # Usage: fetch_race output_file curl_opts url1 url2 ...
    fetch_race() {
        local out=$1 opts=$2
        shift 2
        local urls=("$@")
        local tmps=() pids=()

        for url in "${urls[@]}"; do
            local t
            t=$(mktemp)
            tmps+=("$t")
            # shellcheck disable=SC2086
            curl $opts -s --connect-timeout 3 --max-time 5 "$url" >"$t" \
                2>/dev/null &
            pids+=($!)
        done

        # Poll for first completed result (20ms interval)
        while true; do
            local running=0
            for i in "${!pids[@]}"; do
                [[ -z "${pids[$i]}" ]] && continue

                if kill -0 "${pids[$i]}" 2>/dev/null; then
                    running=$((running + 1))
                else
                    # Process finished - check result
                    if [[ -s "${tmps[$i]}" ]]; then
                        cat "${tmps[$i]}" >"$out"
                        # Kill remaining processes
                        for p in "${pids[@]}"; do
                            [[ -n "$p" ]] && kill "$p" 2>/dev/null
                        done
                        wait 2>/dev/null
                        rm -f "${tmps[@]}" 2>/dev/null
                        return 0
                    fi
                    pids[$i]=""
                fi
            done

            [[ $running -eq 0 ]] && break
            sleep 0.005
        done

        rm -f "${tmps[@]}" 2>/dev/null
    }

    tmp_file=$(mktemp "${cache_dir}/internet.env.XXXXXX")

    # Run all three categories in parallel, each racing multiple services
    fetch_race "${tmp_file}.pub4" "-4" \
        "ifconfig.co" \
        "icanhazip.com" \
        "api.ipify.org" \
        "ifconfig.me" \
        "ip.me" &

    fetch_race "${tmp_file}.pub6" "-6" \
        "ifconfig.co" \
        "icanhazip.com" \
        "api6.ipify.org" \
        "ifconfig.me" \
        "ip.me" &

    fetch_race "${tmp_file}.isp" "" \
        "https://ipinfo.io/org" \
        "http://ip-api.com/line/?fields=org" \
        "https://ipapi.co/org/" &

    wait

    pub4=$(tr -d '\r\n' <"${tmp_file}.pub4" 2>/dev/null || true)
    pub6=$(tr -d '\r\n' <"${tmp_file}.pub6" 2>/dev/null || true)
    isp=$(tr -d '\r\n' <"${tmp_file}.isp" 2>/dev/null || true)

    {
        [[ -n "$pub4" ]] && printf '%s\n' "pub4=${pub4}"
        [[ -n "$pub6" ]] && printf '%s\n' "pub6=${pub6}"
        [[ -n "$isp" ]] && printf '%s\n' "isp=${isp}"
        printf '%s\n' "epoch=$(date +%s)"
    } >"$tmp_file"

    mv -f "$tmp_file" "$cache_file"

    rm -f "${tmp_file}.pub4" "${tmp_file}.pub6" "${tmp_file}.isp" 2>/dev/null \
        || true
    rmdir "$lock_dir" 2>/dev/null || true
) </dev/null >/dev/null 2>&1 &

exit 0

