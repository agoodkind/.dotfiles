#!/usr/bin/env bash
# Display current login sessions with source and readable timestamp

CACHE_FILE="$HOME/.cache/logininfo_session"

# Use gdate on macOS, date on Linux
DATE=$(command -v gdate 2>/dev/null || echo date)
now=$($DATE +%s)
this_year=$($DATE +"%Y")

# Extract remote source from a line (IP or hostname in parentheses)
extract_source() {
    local match
    # First try: anything in parentheses at end of line (most reliable)
    match=$(grep -oE '\([^)]+\)' <<< "$1" | tail -1)
    [[ -n "$match" ]] && { echo "${match//[()]/}"; return; }
    # Fallback: bare IPv4 or IPv6 without parentheses
    match=$(grep -oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+|([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}' <<< "$1" | head -1)
    echo "$match"
}

# Get current session
current_line=$(who am i 2>/dev/null || who -m 2>/dev/null)
[[ -z "$current_line" ]] && exit 0

current_terminal=$(awk '{print $2}' <<< "$current_line")
current_remote=$(extract_source "$current_line")
current_src="${current_remote:-$current_terminal}"

# Read last login from cache (previous session wrote this)
last_terminal="" last_remote="" last_epoch=0
if [[ -f "$CACHE_FILE" ]]; then
    IFS='|' read -r last_terminal last_remote last_epoch < "$CACHE_FILE"
fi
last_src="${last_remote:-$last_terminal}"

# Background: cache current session for next load
( echo "$current_terminal|$current_remote|$now" > "$CACHE_FILE" & )

# Format time difference conversationally
format_relative_time() {
    local diff=$1 epoch=$2
    
    if (( diff < 60 )); then
        echo "just now"
    elif (( diff < 120 )); then
        echo "1 minute ago"
    elif (( diff < 3600 )); then
        echo "$((diff / 60)) minutes ago"
    elif (( diff < 172800 )); then
        local time_str=$($DATE -d "@$epoch" +"%H:%M" 2>/dev/null || $DATE -r "$epoch" +"%H:%M" 2>/dev/null)
        if (( diff < 86400 )); then
            echo "at $time_str"
        else
            echo "at $time_str yesterday"
        fi
    else
        local date_parts
        date_parts=$($DATE -d "@$epoch" +"%d %A %b %H:%M %Y" 2>/dev/null || $DATE -r "$epoch" +"%d %A %b %H:%M %Y" 2>/dev/null)
        read -r day weekday month time login_year <<< "$date_parts"
        day=${day#0}
        
        local suffix="th"
        case $day in
            1|21|31) suffix="st";;
            2|22) suffix="nd";;
            3|23) suffix="rd";;
        esac
        
        if [[ "$login_year" == "$this_year" ]]; then
            echo "on $weekday $month ${day}${suffix} at $time"
        else
            echo "on $weekday $month ${day}${suffix}, $login_year at $time"
        fi
    fi
}

# Color codes
CYAN="\033[1;36m" GREEN="\033[1;32m" YELLOW="\033[1;33m" RESET="\033[0m"

# Build output message
if [[ $last_epoch -gt 0 ]]; then
    diff=$((now - last_epoch))
    when=$(format_relative_time "$diff" "$last_epoch")
    if [[ "$current_src" == "$last_src" ]]; then
        printf "%bCurrently logged in from%b %b%s%b, %blast logged in%b %b%s%b\n" \
            "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET" \
            "$CYAN" "$RESET" "$YELLOW" "$when" "$RESET"
    else
        printf "%bCurrently logged in from%b %b%s%b, %blast logged in from%b %b%s%b %b%s%b\n" \
            "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET" \
            "$CYAN" "$RESET" "$GREEN" "$last_src" "$RESET" "$YELLOW" "$when" "$RESET"
    fi
else
    printf "%bCurrently logged in from%b %b%s%b\n" "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET"
fi
