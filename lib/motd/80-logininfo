#!/usr/bin/env bash
# Display current login sessions with source and readable timestamp

command -v who >/dev/null 2>&1 || { echo "ERROR: 'who' command not found" >&2; exit 1; }
command -v last >/dev/null 2>&1 || { echo "ERROR: 'last' command not found" >&2; exit 1; }

# Use gdate on macOS, date on Linux
DATE=$(command -v gdate 2>/dev/null || echo date)
user=$(whoami)
now=$($DATE +%s)

# Format source: use IP if available, otherwise terminal name
format_source() {
    echo "${2:-$1}"
}

# Get current session from 'who am i' or current TTY
# Format: user terminal date time (ip)
current_line=$(who am i 2>/dev/null || who -m 2>/dev/null || echo "")
if [[ -z "$current_line" ]]; then
    # Fallback: try to get from who output
    current_line=$(who | grep "$user" | tail -1)
fi

if [[ -z "$current_line" ]]; then

    exit 0
fi

# Parse current session
current_fields=($current_line)
current_terminal="${current_fields[1]}"
current_ip=""

# Extract IP from remaining fields (field 4+ with parentheses)
for field in "${current_fields[@]:4}"; do
    if [[ "$field" =~ ^\( ]]; then
        current_ip="${field//[()]/}"
        break
    fi
done

current_src=$(format_source "$current_terminal" "$current_ip")

# Get last login from 'last' command
# 'last' shows most recent entries first
# Use the first entry, but if it matches current session, use the second entry
last_output=$(last "$user" 2>/dev/null | head -2)
first_line=$(echo "$last_output" | head -1)
second_line=$(echo "$last_output" | tail -1)

# Check if first entry matches current session
first_terminal=$(echo "$first_line" | awk '{print $2}')
if [[ "$first_terminal" == "$current_terminal" ]]; then
    # First entry is current session, use second entry for previous login
    last_line="$second_line"
else
    # First entry is a previous login, use it
    last_line="$first_line"
fi

last_epoch=0
last_src=""

if [[ -n "$last_line" ]]; then
    # Parse last login line
    # Format: agoodkind  ttys010                         Sun Nov 23 14:24 - 14:24  (00:00)
    # or:     agoodkind  pts/0       192.168.1.1        Mon Nov 22 10:30 - 10:45  (00:15)
    last_fields=($last_line)
    last_terminal="${last_fields[1]}"
    
    # Find the date/time fields (skip terminal, find day of week)
    # Day of week is typically field 2, but terminal might have spaces
    # Look for pattern: Day Month DD HH:MM
    day_idx=2
    while [[ $day_idx -lt ${#last_fields[@]} ]]; do
        if [[ "${last_fields[$day_idx]}" =~ ^(Mon|Tue|Wed|Thu|Fri|Sat|Sun)$ ]]; then
            break
        fi
        ((day_idx++))
    done
    
    if [[ $day_idx -lt ${#last_fields[@]} ]]; then
        last_day="${last_fields[$day_idx]}"
        last_month="${last_fields[$((day_idx+1))]}"
        last_date="${last_fields[$((day_idx+2))]}"
        last_time="${last_fields[$((day_idx+3))]}"
        
        # Try to extract IP (might be between terminal and date)
        last_ip=""
        for ((i=2; i<day_idx; i++)); do
            if [[ "${last_fields[$i]}" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]] || [[ "${last_fields[$i]}" =~ ^[0-9a-fA-F:]+$ ]]; then
                last_ip="${last_fields[$i]}"
                break
            fi
        done
        
        # Build datetime string for parsing
        # macOS last format: "Sun Nov 23 14:24"
        last_datetime="$last_day $last_month $last_date $last_time"
        
        # Parse to epoch (handle both macOS and Linux formats)
        last_epoch=$($DATE -d "$last_datetime" +%s 2>/dev/null || $DATE -j -f "%a %b %d %H:%M" "$last_datetime" +%s 2>/dev/null || echo "0")
        
        if [[ $last_epoch -gt 0 ]]; then
            last_src=$(format_source "$last_terminal" "$last_ip")
        fi
    fi
fi

# Format time difference conversationally
format_relative_time() {
    local diff=$1 epoch=$2
    
    if (( diff < 60 )); then
        echo "just now"
    elif (( diff < 120 )); then
        echo "1 minute ago"
    elif (( diff < 3600 )); then
        echo "$((diff / 60)) minutes ago"
    elif (( diff < 86400 )); then
        echo "at $($DATE -d "@$epoch" +"%H:%M")"
    elif (( diff < 172800 )); then
        echo "at $($DATE -d "@$epoch" +"%H:%M") yesterday"
    else
        local day=$($DATE -d "@$epoch" +"%d" | sed 's/^0*//')
        local suffix="th"
        case $day in
            1|21|31) suffix="st";;
            2|22) suffix="nd";;
            3|23) suffix="rd";;
        esac
        
        local weekday=$($DATE -d "@$epoch" +"%A")
        local month=$($DATE -d "@$epoch" +"%b")
        local time=$($DATE -d "@$epoch" +"%H:%M")
        local login_year=$($DATE -d "@$epoch" +"%Y")
        local this_year=$($DATE +"%Y")
        
        if [[ "$login_year" == "$this_year" ]]; then
            echo "on $weekday $month ${day}${suffix} at $time"
        else
            echo "on $weekday $month ${day}${suffix}, $login_year at $time"
        fi
    fi
}

# Color codes
CYAN="\033[1;36m" GREEN="\033[1;32m" YELLOW="\033[1;33m" RESET="\033[0m"

# Build output message
if [[ $last_epoch -gt 0 ]]; then
    diff=$((now - last_epoch))
    when=$(format_relative_time "$diff" "$last_epoch")
    if [[ "$current_src" == "$last_src" ]]; then
        # Same location - don't repeat it
        printf "%bCurrently logged in from%b %b%s%b, %blast logged in%b %b%s%b\n" \
            "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET" \
            "$CYAN" "$RESET" "$YELLOW" "$when" "$RESET"
    else
        # Different location - show both
        printf "%bCurrently logged in from%b %b%s%b, %blast logged in from%b %b%s%b %b%s%b\n" \
            "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET" \
            "$CYAN" "$RESET" "$GREEN" "$last_src" "$RESET" "$YELLOW" "$when" "$RESET"
    fi
else
    printf "%bCurrently logged in from%b %b%s%b\n" "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET"
fi
