#!/usr/bin/env bash
# Display current login sessions with source and readable timestamp

# Check for required utilities
command -v who >/dev/null 2>&1 || { echo "ERROR: 'who' command not found" >&2; exit 1; }

# Use gdate on macOS, date on Linux
if command -v gdate >/dev/null 2>&1; then
    DATE=gdate
else
    DATE=date
fi

# Get current user and timestamp
user=$(whoami)
now=$($DATE +%s)

# Function to format source: use IP if available, otherwise terminal name
format_source() {
    local terminal="$1"
    local ip="$2"
    if [[ -n "$ip" ]]; then
        echo "$ip"
    else
        echo "$terminal"
    fi
}

# Parse login sessions - handle both macOS (YYYY-MM-DD HH:MM) and Linux (MMM DD HH:MM) formats
# Extract: terminal|date time|ip (if available)
sessions=$(who | awk -v u="$user" '$1==u {
    # macOS: agoodkind console 2025-11-10 15:41
    # macOS SSH: agoodkind ttys000 2025-11-10 15:41 (192.168.1.100)
    # Linux: agoodkind pts/0 2025-11-13 14:36 (192.168.1.100)
    # Linux IPv6: agoodkind pts/0 2025-11-13 14:36 (fd00:bad:b01:1::15c6)
    terminal = $2
    ip = ""
    
    if ($3 ~ /^[0-9]{4}-[0-9]{2}-[0-9]{2}$/) {
        # macOS format: YYYY-MM-DD HH:MM
        datetime = $3 " " $4
        # IP might be in $5 (if present)
        if (NF > 4 && $5 ~ /^\(/) {
            # Remove parentheses and extract IP
            gsub(/[()]/, "", $5)
            ip = $5
        }
    } else {
        # Linux format: MMM DD HH:MM (possibly with IP in parentheses)
        datetime = $3 " " $4
        # Look for IP in remaining fields (usually in $5 with parentheses)
        for (i = 5; i <= NF; i++) {
            if ($i ~ /^\(/) {
                # Found field with parentheses - extract IP
                gsub(/[()]/, "", $i)
                ip = $i
                break
            }
        }
    }
    print terminal "|" datetime "|" ip
}')

[[ -z "$sessions" ]] && { echo "No login sessions found"; exit 0; }

# Extract current session info
current_line=$(echo "$sessions" | head -n1)
current_terminal=$(echo "$current_line" | cut -d'|' -f1)
current_ip=$(echo "$current_line" | cut -d'|' -f3)
current_src=$(format_source "$current_terminal" "$current_ip")

# Extract last session info
last_line=$(echo "$sessions" | tail -n1)
last_terminal=$(echo "$last_line" | cut -d'|' -f1)
last_time=$(echo "$last_line" | cut -d'|' -f2 | xargs)
last_ip=$(echo "$last_line" | cut -d'|' -f3)
last_src=$(format_source "$last_terminal" "$last_ip")

# Parse last login epoch - handle both date formats
if [[ "$last_time" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2} ]]; then
    # macOS format: YYYY-MM-DD HH:MM
    last_epoch=$($DATE -d "$last_time" +%s 2>/dev/null || echo "0")
else
    # Linux format: MMM DD HH:MM
    last_epoch=$($DATE -d "$last_time" +%s 2>/dev/null || $DATE -d "${last_time}:00" +%s 2>/dev/null || echo "0")
fi

# Format time difference conversationally
format_relative_time() {
    local diff=$1
    local epoch=$2
    
    if (( diff < 10 )); then
        echo "just now"
    elif (( diff < 60 )); then
        echo "${diff}s ago"
    elif (( diff < 120 )); then
        echo "1 minute ago"
    elif (( diff < 3600 )); then
        echo "$((diff / 60)) minutes ago"
    elif (( diff < 86400 )); then
        # Same day - show time only
        local time=$($DATE -d "@$epoch" +"%H:%M")
        echo "at $time"
    elif (( diff < 172800 )); then
        # Yesterday - show time and "yesterday"
        local time=$($DATE -d "@$epoch" +"%H:%M")
        echo "at $time yesterday"
    else
        # Older - show full date
        local day=$($DATE -d "@$epoch" +"%d" | sed 's/^0*//')
        local suffix="th"
        case $day in
            1|21|31) suffix="st";;
            2|22) suffix="nd";;
            3|23) suffix="rd";;
        esac
        
        local weekday=$($DATE -d "@$epoch" +"%A")
        local month=$($DATE -d "@$epoch" +"%b")
        local time=$($DATE -d "@$epoch" +"%H:%M")
        local this_year=$($DATE +"%Y")
        local login_year=$($DATE -d "@$epoch" +"%Y")
        
        if [[ "$login_year" == "$this_year" ]]; then
            echo "on $weekday $month ${day}${suffix} at $time"
        else
            echo "on $weekday $month ${day}${suffix}, $login_year at $time"
        fi
    fi
}

# Color codes
CYAN="\033[1;36m"
GREEN="\033[1;32m"
YELLOW="\033[1;33m"
RESET="\033[0m"

# Build output message
if [[ $last_epoch -gt 0 ]]; then
    diff=$((now - last_epoch))
    when=$(format_relative_time "$diff" "$last_epoch")
    
    if (( diff < 3600 )); then
        # Recent: "Currently logged in from X, last logged in from Z Y ago"
        printf "%bCurrently logged in from%b %b%s%b, " "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET"
        printf "%blast logged in from%b %b%s%b %b%s%b\n" "$CYAN" "$RESET" "$GREEN" "$last_src" "$RESET" "$YELLOW" "$when" "$RESET"
    else
        # Older: "Currently logged in from X, last logged in from Z at/on Y"
        printf "%bCurrently logged in from%b %b%s%b, " "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET"
        printf "%blast logged in from%b %b%s%b %b%s%b\n" "$CYAN" "$RESET" "$GREEN" "$last_src" "$RESET" "$YELLOW" "$when" "$RESET"
    fi
else
    # Single session or parse failure
    printf "%bCurrently logged in from%b %b%s%b\n" "$CYAN" "$RESET" "$GREEN" "$current_src" "$RESET"
fi
