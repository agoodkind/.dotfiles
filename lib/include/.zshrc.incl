# shellcheck shell=bash
# Check if profiling was requested and load zprof module early if needed
SHOULD_PROFILE=false
if [[ -f ~/.cache/zsh_profile_next ]]; then
    SHOULD_PROFILE=true
    zmodload zsh/zprof
    rm ~/.cache/zsh_profile_next

    do_profile() {
        echo "Zsh performance profiling results:"
        zprof
        echo "Zsh initialization time: $(( ($(date +%s%N) - START_TIME) / 1000000 )) ms"
    }
fi
export SHOULD_PROFILE

source "$DOTDOTFILES/lib/include/.zshrc.plugins"


# Run this function to enable profiling for the next shell session
zsh_profile() {
    mkdir -p ~/.cache
    touch ~/.cache/zsh_profile_next
    echo "Performance profiling enabled for next shell session"
}


# Dotfiles async update - source directly to avoid zinit plugin management
source "$DOTDOTFILES/lib/include/.zshrc.utils"
(zsh "$DOTDOTFILES/lib/include/.zshrc.updater" >/dev/null 2>&1 &)
source "$DOTDOTFILES/lib/include/.zshrc.zoxide"
source "$DOTDOTFILES/lib/include/.zshrc.motd"


# Load local zshrc customizations that are not to be tracked by git
[[ ! -f "$DOTDOTFILES/.zshrc.local" ]] || source "$DOTDOTFILES/.zshrc.local"

# if ~/.cache/dotfiles_update_next exists
# interactively ask if user wants to update
# if yes, run config update and then reload
# if no, make another file ~/.cache/dotfiles_update_skipped to avoid asking again
# Skip update check if we're already in the middle of a reload
if [[ -f ~/.cache/dotfiles_update_next ]] && [[ ! -f ~/.cache/dotfiles_update_skipped ]] && [[ -z "$_RELOADING" ]]; then
    # printf "Dotfiles update available. Do you want to update now? (y/n) "
    # read answer
    # if [[ "$answer" == "y" || "$answer" == "Y" ]]; then
        rm ~/.cache/dotfiles_update_next
        echo "Dotfiles update detected."
        config update
    # else 
    #     touch ~/.cache/dotfiles_update_skipped
    #     echo "Dotfiles update skipped."
    # fi
fi

